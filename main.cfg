/**
 *  @fileOverview Grace
 */

/* need to use the CSL module to generate the CSL code */
var CSL = xdc.useModule('ti.mcu.msp430.csl.CSL');
var EUSCI_A1 = xdc.useModule('ti.mcu.msp430.csl2.communication.EUSCI_A1');
var PMM = xdc.useModule('ti.mcu.msp430.csl2.pmm.PMM');
var EUSCI_A0 = xdc.useModule('ti.mcu.msp430.csl2.communication.EUSCI_A0');
var EUSCI_B0 = xdc.useModule('ti.mcu.msp430.csl2.communication.EUSCI_B0');
var Timer1_A3 = xdc.useModule('ti.mcu.msp430.csl2.timer.Timer1_A3');
var RTC_B = xdc.useModule('ti.mcu.msp430.csl2.rtc.RTC_B');
CSL.configApiVersion = "1.30.00";  /* 1.30 added the PinMux module */

/* these modules should be part of every project */
var CS = xdc.useModule('ti.mcu.msp430.csl2.clock.CS_A');
var WDT_A = xdc.useModule('ti.mcu.msp430.csl2.watchdog.WDT_A');
var System = xdc.useModule('ti.mcu.msp430.csl2.system.System');
var GPIO = xdc.useModule('ti.mcu.msp430.csl2.gpio.GPIO');
var PinMux = xdc.module('ti.mcu.msp430.csl2.pinmux.PinMux');
var InterruptVectors = xdc.useModule('ti.mcu.msp430.csl.interrupt_vectors.InterruptVectors');

/* set stack and heap sizes as appropriate for MSP430 */
Program.sysStack = 0;
Program.stack = 64;
Program.heap = 0;
Program.argSize = 0;

/* Enable global interrupt */
System.srRegs.SR.GIE = System.srDefs.GIE;
CS.clockMode = xdc.module("ti.mcu.msp430.csl2.clock.IClock").ClockConfigMode;
CS.regs.XT1CLKHz = 32768.0;
PinMux.assignedPins = "P1.0 GPIO,P1.1 GPIO,P1.2 Timer1_A3,P1.3 GPIO,P1.4 GPIO,P1.5 EUSCI_A0_SPI,P1.6 EUSCI_B0_SPI,P1.7 EUSCI_B0_SPI,P2.0 EUSCI_A0_SPI,P2.1 EUSCI_A0_SPI,P2.2 EUSCI_B0_SPI,P2.3 EUSCI_A1_SPI,P2.4 EUSCI_A1_SPI,P2.5 EUSCI_A1_SPI,P2.6 GPIO,P2.7 GPIO,P3.0 GPIO,P3.1 GPIO,P3.2 GPIO,P3.4 GPIO,P3.5 GPIO,P3.6 GPIO,PJ.4 LFXIN,PJ.5 LFXOUT";
PinMux.regs.pjsel0 = 48;
CS.csAclkSource = CS.CSA_LFXTCLK_SELECT;
CS.csMclkSrcDivider = CS.CSA_CLOCK_DIVIDER_4;
EUSCI_A1.eusciMode = EUSCI_A1.eusciBaseDefs.SPIMode;
CS.csSmclkSrcDivider = CS.CSA_CLOCK_DIVIDER_2;
EUSCI_A1.eusciSPI.eusciSPIBitRate = EUSCI_A1.eusciSPIDefs.SPIBitRate_7;
EUSCI_A1.eusciSPI.eusciSPIPin[0] = 1;
PinMux.regs.p2sel1 = 63;
EUSCI_A1.eusciSPI.eusciSPIPin[2] = 1;
EUSCI_A1.eusciSPI.eusciSPIMode = EUSCI_A1.eusciSPIDefs.MasterMode_4Wire;
EUSCI_A1.eusciSPI.eusciSPIPin[3] = 1;
EUSCI_A1.eusciSPI.eusciSPISBSel = EUSCI_A1.eusciSPIDefs.eSPI_MSB_FIRST;
EUSCI_A1.eusciSPI.eusciSPIClockPhase = EUSCI_A1.eusciSPIDefs.eSPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT;
CSL.device.vcc = 3.3;
PMM.showUserModePage = false;
PinMux.regs.p2dir = 192;
PinMux.regs.p2out = 0;
EUSCI_A1.eusciSPI.eusciSPISTEMode = EUSCI_A1.eusciSPIDefs.SPISTEMode_1;
PinMux.regs.p1sel1 = 224;
PinMux.regs.p1dir = 31;
PinMux.regs.p1sel0 = 4;
CS.csAdvSettingsEnabled = false;
CS.csXt1Bypass = false;
CS.csXt1Drive = CS.LFXTDRIVE_2;
EUSCI_A1.eusciSPI.eusciSPICustomRate = 1000000;
PinMux.regs.p3ren = 112;
PinMux.regs.p3out = 113;
EUSCI_A0.eusciMode = EUSCI_A0.eusciBaseDefs.SPIMode;
EUSCI_A0.eusciSPI.eusciSPIBitRate = EUSCI_A0.eusciSPIDefs.SPIBitRate_7;
EUSCI_A0.eusciSPI.eusciSPIPin[0] = 1;
EUSCI_A0.eusciSPI.eusciSPIPin[1] = 1;
EUSCI_A0.eusciSPI.eusciSPIPin[2] = 1;
EUSCI_A0.eusciSPI.eusciSPISBSel = EUSCI_A0.eusciSPIDefs.eSPI_MSB_FIRST;
EUSCI_A0.eusciSPI.eusciSPIClockPhase = EUSCI_A0.eusciSPIDefs.eSPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT;
PinMux.regs.p1out = 3;
PinMux.regs.p3dir = 5;
PinMux.regs.p2ren = 2;
EUSCI_B0.eusciMode = EUSCI_B0.eusciBaseDefs.SPIMode;
EUSCI_B0.eusciSPI.eusciSPIPin[0] = 1;
EUSCI_B0.eusciSPI.eusciSPIPin[1] = 1;
EUSCI_B0.eusciSPI.eusciSPIPin[2] = 1;
EUSCI_B0.eusciSPI.eusciSPIBitRate = EUSCI_B0.eusciSPIDefs.SPIBitRate_4;
EUSCI_B0.eusciSPI.eusciSPISBSel = EUSCI_B0.eusciSPIDefs.eSPI_MSB_FIRST;
EUSCI_B0.eusciSPI.eusciSPIClockPhase = EUSCI_B0.eusciSPIDefs.eSPI_PHASE_DATA_CAPTURED_ONFIRST_CHANGED_ON_NEXT;
EUSCI_B0.regs.interruptSource[1].interruptEnable = false;
EUSCI_B0.regs.interruptSource[1].interruptHandler = false;
EUSCI_B0.regs.interruptSource[0].interruptHandler = false;
EUSCI_B0.regs.interruptSource[2].interruptHandler = false;
EUSCI_B0.regs.interruptSource[3].interruptHandler = false;
EUSCI_B0.regs.interruptSource[4].interruptHandler = false;
EUSCI_B0.regs.interruptSource[5].interruptHandler = false;
EUSCI_B0.regs.interruptSource[6].interruptHandler = false;
EUSCI_B0.regs.interruptSource[7].interruptHandler = false;
EUSCI_B0.regs.interruptSource[8].interruptHandler = false;
EUSCI_B0.regs.interruptSource[9].interruptHandler = false;
EUSCI_B0.regs.interruptSource[10].interruptHandler = false;
EUSCI_B0.regs.interruptSource[11].interruptHandler = false;
EUSCI_B0.regs.interruptSource[12].interruptHandler = false;
EUSCI_B0.regs.interruptSource[0].interruptEnable = false;
EUSCI_B0.eusciSPI.eusciSPIMode = EUSCI_B0.eusciSPIDefs.MasterMode_3Wire;
Timer1_A3.timerMode = xdc.module("ti.mcu.msp430.csl2.timer.ITimer").PWMMode;
Timer1_A3.intervalModeAdvanced = true;
Timer1_A3.TACTL.timerClockSource = xdc.module("ti.mcu.msp430.csl2.timer.ITimer_A").TIMERA_CLOCKSOURCE_SMCLK;
Timer1_A3.inputClockToTimer = 8000.0;
Timer1_A3.ccrOutputPin[1] = 1;
Timer1_A3.ccrOutputPinAssigned[1] = true;
Timer1_A3.PWMModeActive = true;
Timer1_A3.compareValue[1] = 3;
Timer1_A3.TACCTL1.timerOutputMode = xdc.module("ti.mcu.msp430.csl2.timer.ITimer_A").TIMERA_OUTPUTMODE_RESET_SET;
Timer1_A3.pwmDesiredFrequency = 1000000.0;
Timer1_A3.intervalDesiredPeriod = 0.001;
Timer1_A3.compareValue[0] = 7;
PinMux.regs.p3ie = 0;
PinMux.regs.p3ies = 0;
CS.csDcoRangeSel = CS.CSA_DCORSEL_1;
CS.csDcoFreqSel = CS.CSA_DCOFSEL_4;
CS.csMclkSource = CS.CSA_DCOCLK_SELECT;
RTC_B.calendarModePage = true;
RTC_B.rtcFormat = RTC_B.RTC_FORMAT_BCD;
RTC_B.rtcCalendarDateMonth = RTC_B.RTC_CALENDARDATE_MONTH_AUGUST;
RTC_B.rtcCalendar.dayOfMonth = 5;
RTC_B.rtcCalendar.year = 2015;
RTC_B.startClock = true;
RTC_B.regs.interruptSource[3].interruptEnable = false;
RTC_B.regs.interruptSource[3].interruptHandler = false;
RTC_B.regs.interruptSource[0].interruptHandler = false;
RTC_B.regs.interruptSource[1].interruptHandler = false;
RTC_B.regs.interruptSource[2].interruptHandler = false;
RTC_B.regs.interruptSource[2].interruptEnable = false;
